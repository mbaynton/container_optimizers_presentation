{
  "hash": "6bf99b803adb476aa9ac155e0b3b8899",
  "result": {
    "markdown": "---\ntitle: \"Container Optimizers Presentation\"\nformat: revealjs\n---\n\n## Containers! {auto-animate=\"true\"}\n\n![](docker-container.jpg.webp){style=\"margin-left: auto; margin-right: auto; width: 29%\"}\n\n::: {.incremental .fig-right}\nMike Baynton<br /> Hosted Apps\n:::\n\n## Optimized Containers! {auto-animate=\"true\"}\n\n![](docker-container.jpg.webp){style=\"margin-left: 20%; width: 29%\"} ![](rapid-rabit.jpg){style=\"margin-right: 20%; width: 30%\"}\n\n## Wait, Containers?\n\n::: incremental\n-   An easy way to get nearly any software up and running on nearly any computer.\n\n-   All you really need to know is the name of the **container image** you want to run.\n\n-   Instead of [installing R](https://rstudio-education.github.io/hopr/starting.html){preview-link=\"true\"}, you could just run\n\n\n    ```{bash}\n    docker run -ti r-base\n    ```\n\n:::\n\n## Containers in the cloud\n\nIn the cloud, a sea of compute needs to be paired with myriad software.\n\n::: incremental\n![](cpu.png){.absolute top=\"300\" left=\"30\" width=\"250\"}\n\n![](cpu.png){.absolute .fragment autoslide=\"650\" top=\"500\" left=\"200\" width=\"250\"} ![](cpu.png){.absolute .fragment autoslide=\"650\" top=\"310\" left=\"550\" width=\"250\"}\n\n![](cpu.png){.absolute .fragment autoslide=\"650\" top=\"225\" right=\"30\" width=\"250\"}\n\n![](cloud-icons/apache.png){.absolute .fragment autoslide=\"650\" top=\"605\" left=\"230\" width=\"190\"} ![](cloud-icons/envoy-horizontal-color.png){.absolute .fragment autoslide=\"650\" top=\"405\" left=\"55\" width=\"190\"} ![](cloud-icons/mysql.png){.absolute .fragment autoslide=\"650\" top=\"360\" right=\"270\" width=\"190\"}\n\n![](cloud-icons/shiny.png){.absolute .fragment top=\"255\" right=\"60\" width=\"190\"}\n:::\n\n## But there's a problem...\n\n![](image_unpack.gif){fig-align=\"center\"}\n\nDownloading and extracting the image can be slow.\n\n## Here's the cool part\n\nContainers are so ubiquitious, you can always bet people are solving hard problems for you to improve them.\n\n### Our heroes:\n\n::: incremental\n-   [stargz-snapshotter](https://github.com/containerd/stargz-snapshotter), the original\n-   [SOCI Snapshotter](https://github.com/awslabs/soci-snapshotter), AWS-sponsored fork\n:::\n\n## How do they work?\n\nThey let the container start to run on the new computer before most of its image has downloaded.\n\n::: fragment\n![](mind-blown.png){fig-align=\"center\"}\n:::\n\n## A little deeper\n\nWhat if the software in the container tries to access a file that hasn't been downloaded yet?\n\n-  A special filesystem pretends it knows all about that file already, but in fact\n   it starts a download on-demand for the region of the container image where the requested\n   file resides.\n\n-  From the software's point of view, the data is all there, it's just suspiciously *slow...*\n   \n# Container optimizers and Posit\n\nThese optimizers are a little too early in development for us to use them right away,\nbut...\n\n## Posit's hosted team products all use containers!\n\n-   shinyapps.io\n\n    -   Every application gets its own container image\n\nWe can't always have every customer application image pre-downloaded to a\nserver with free capacity to run it.\n\nThe person trying to view the shiny app waits a long time in this case today.\n\n## Optimizing the optimizer\n\n::: incremental\n-  Our hero, stargz-snapshotter, includes a tool to automatically profile a container\n   and record which areas of the container image are accessed right away.\n\n-  This most critical data can be downloaded first, then the container is started.\n   Remaining, less critical data continues to be downloaded in the background.\n:::\n\n",
    "supporting": [
      "container_optimizers_presentation_files/figure-revealjs"
    ],
    "filters": [],
    "includes": {}
  }
}